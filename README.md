# 1. 컴퓨터의 구성
하드웨어 : 컴퓨터를 구성하는 기계적 장치 ( ex) SDD 하드, HDD 하드 등 )
* 중앙처리장치 
* 기억장치
* 입출력 장치

소프트웨어 : 하드웨어의 동작을 지시하고 제어하는 명령어 집합 ( ex) 운영체제 등에서 사용하는 프로그램들 )
* 시스템 소프트웨어
* 응용 소프트웨어

중앙처리 장치
* 산술논리연산장치
* 제어장치
* 레지스터

기억 장치
* 주기억장치 
* 보조기억장치

입출력 장치
* 입력 - 키보드, 마우스
* 출력 - 프린터, 모니터, 스피커

```
RAM(Random ACcess Memory) 이란?
- RAM 휘발성 메모리로, 작업 중인 파일을 한시적으로 저장합니다.

ROM(Read Only Memory) 이란?
- 컴퓨터에 지시사항을 영구히 저장하는 비휘발성 메모리
```

시스템 버스
* 데이터 버스 - 데이터 연결 통로
* 주소 버스 - 말 그대로 주소를 정해주는 버스
* 제어 버스 - 모든 장치에 공유되는 부분을 제어하는 수단

컴퓨터의 처리과정
- Read---> Process ---> Write

---

# 2. 중앙처리장치(CPU) 작동 원리

CPU - 인간의 두뇌에 해당

* 연산 장치
* 제어 장치
* 레지스터

연산 장치
- 산술연산과 논리연산을 수행

제어 장치
- 명령어를 순서대로 실행할 수 있도록 제어하는 장치

레지스터
- 고속 기억장치
- 범용 레지스터 / 특수목적 레지스터로 구분

### 특수 목적 레저스터 종류
- MAR(메모리 주소 레지스터) / PC(프로그램 카운터) / IR(명령어 레지스터) / MBR(메모리 버퍼 레지스터) / AC(누산기)
```
MAR(메모리 주소 레지스터)란?
- 데이터의 주소를 기억하는 레지스터

PC(프로그램 카운터)란 ?
- 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정하기 때문에 명령어 포인터라고도 한다.

IR(명령어 레지스터)란?
- 현재 실행 중인 명령을 기억하는 레지스터

MBR(메모리 버퍼 레지스터)란?
- 데이터를 임시로 기억하는 레지스터로 데이터를 처리하기 위해 반드시 거쳐가게 됨

AC(누산기)란?
- 연산 결과를 임시로 저장하는 레지스터
```


### CPU의 동작 과정
1. 저장된 프로그램을 읽어오고
2. 처리한 데이터를 다시 주기억장치에 저장
3. 처리 결과를 보조기억장치에 저장하거나 출력
4. 제어장치가 1~3의 과정이 순서대로 실행할 수 있도록 제어

#### 명령어 세트 
- CPU가 실행할 명령어의 집합

> 연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐   
> 연산 코드 : 실행할 연산   
> 피연산자 : 필요한 데이터 or 저장 위치

연산 코드 - 연산, 제어, 데이터 전달, 입출력
피연산자 - 주소, 숫자/문자, 논리 데이터 등을 저장

```
명령어 사이클이란?
- CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동
- 인출/실행/간접/인터럽트
- 주기억장치에서 하나의 명령어를 가져오고, 실행 사이클에서는 명령어를 실행 후 해당 실행이 완료되면 다음 명령어에 대한 인출 사이클 시작
```

#### 인출 사이클에서 가장 중요한 부분 : PC(프로그램 카운터) 값 증가

1. PC에 저장된 주소를 MAR로 전달

2. 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출

3. 인출한 명령어를 MBR에 저장

4. 다음 명령어를 인출하기 위해 PC 값 증가시킴

5. 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달

---


# 3. 캐시 메모리(Cache Memory)

- 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.
- 속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.
- CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다. (L1, L2, L3 캐시 메모리라고 부른다)
속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용된다. (CPU에서 가장 빠르게 접근하고, 여기서 데이터를 찾지 못하면 L2로 감)

- L1 : CPU내부에 존재
- L2 : CPU와 RAM 사이에 존재
- L3 : 보통 메인보드에 존재

> 캐시 메모리 크기가 작은 이유는 , SRAM 가격이 매우 비싸기 때문

- 디스크 캐시 : RAM과 하드디스크 사이에 존재하는 캐시

- 캐시 메모리 작동 원리
1. 시간 지역성 - 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높음
2. 공간 지역성 - 리스트에 연속된 값을 접근할시 Ex) A[1], A[2] 에 참조된 데이터 근처에 있는 데이터가 잠시후 재사용될 가능성이 높음


CPU가 요청한 데이터가 캐시에 있으면 Cache hit, 없어서 DRAM에서 가져오는 경우에는 Cache Miss

- 캐시 미스 3가지

1. Cold miss - 해당 메모리 주소를 처음 불러서 나는 미스
2. Conflict miss - A,B가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스
3. Capacity miss - 용량 부족으로 인해 나는 미스 (Conflict는 주소 할당 문제, Capacity는 공간 문제)


구조 및 작동 방식
1. Direct Mapped Cache

<img width="296" alt="image" src="https://user-images.githubusercontent.com/104750108/168505240-0d9d5eb2-ada2-4c22-be3f-99d3cafd33cb.png">


- 가장 기본적인 구조이고 DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응 되는 다대일 방식
- 인덱스 필드 + 태그 필드 + 데이터 필드로 구성
- 간단하고 빠르다는 장점이 있지만, Conflict Miss(캐시 미스 3종류 중 하나)가 발생하는 단점

2. Fully Associative Cache

- 비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식
- 저장은 쉬우나 찾을 때 어려움이 있음
- 조건이나 규칙이 없어 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야함
- CAM이라는 특수한 메모리 구조를 사용해야하고 가격이 매우 비싼게 단점

3. Set Associative Cache

- Direct + Fully의 결합 방식이다. 
- Direct보다 검색 속도는 느리나 저장이 빠르고 Fully보다 저장이 느린 대신 검색이 빠른 중간형 캐시이다.


---

# 4. 고정 소수점 & 부동 소수점

1) 고정 소수점

- 소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 ( 정수 + 소수)

```
-3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소가 필요함
```

<img width="319" alt="image" src="https://user-images.githubusercontent.com/104750108/168506022-b501ca30-a584-4698-9031-eed30a68b492.png">

- 장점 : 실수를 정수부와 소수부로 표현하여 단순하다.

- 단점 : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)

2) 부동 소수점

실수를 가수부 + 지수부로 표현한다.

> 가수 : 실수의 실제값 표현
>> 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄

지수의 값에 따라 소수점이 움직이는 방식을 활용한 실수 표현 방법이고 소수점의 위치가 고정되어 있지 않다.

<img width="318" alt="image" src="https://user-images.githubusercontent.com/104750108/168506160-0fff6781-3722-405f-8ec4-3dc6ce09a2c2.png">

- 장점 : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)

- 단점 : 오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)

# 5. 패리티 비트 & 해밍 코드

- 패리티 비트
> 정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트
> 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송

종류 : 짝수, 홀수

전체 비트에서 ( 짝수, 홀수 )에 맞도록 비트를 정하는 것

- 짝수 패리티일 때 7비트 데이터가 1010001이라면?
> 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함
> 정답 : 11010001 ( 제일 앞에 패리티비트 )

- 해밍 코드
> 데이터 전송시 1비트의 에러를 정정할 수 있는 자기 오류 정정 코드를 말함
> 패리티비트를 보고, 비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. (패리티 비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)

- 방법
2의 n제곱 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로 부터 시작한다. 
이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.

- 짝수 패리티의 해밍코드가 0011011일때 오류가 수정된 코드는?
1.  1,3,5,7번째 : 0101로 짝수이므로 '0'
2.  2,3,6,7번째 : 0111로 홀수이므로 '1'
3.  4,5,6,7번째 : 1011로 홀수이므로 '1'

역순으로 패리티비트 '110'을 도출 후 10진법으로 바꾸면 6이 되므로 6번째 비트 수정
답 : 0011001

# 6. ARM 프로세서

- Processor?
> 메모리에 저장된 명령어들을 실행하는 유한 상태 오토마톤

ARM : Advanced RISC Machine

RISC : Reduced Instruction Set Computing(감소된 명령 집합 컴퓨팅)

`단순한 명령 집합을 가진 프로세서`가 `복잡한 명령 집합을 가진 프로세서`보다 훨씬 더 효율적이지 않을까? 로 탄생함

### ARM 구조

<img width="279" alt="image" src="https://user-images.githubusercontent.com/104750108/169721660-6f48eeac-3a81-42d1-a21f-5a011370a4bf.png">

ARM은 칩의 기본 설계 구조만 만들고, 실제 기능 추가와 최적화 부분은 개별 반도체 제조사의 영역으로 맡긴다. 
따라서 물리적 설계는 같아도, 명령 집합이 모두 다르기 때문에 서로 다른 칩이 되기도 하는 것이 ARM.

소비자에게는 칩이 논리적 구조인 명령 집합으로 구성되면서, 이런 특성 때문에 물리적 설계 베이스는 같지만 용도에 따라 다양한 제품군을 만날 수 있는 특징이 있다.

아무래도 아키텍처는 논리적인 명령 집합을 물리적으로 표현한 것이므로, 명령어가 많고 복잡해질수록 실제 물리적인 칩 구조도 크고 복잡해진다.

하지만, ARM은 RISC 설계 기반으로 '단순한 명령집합을 가진 프로세서가 복잡한 것보다 효율적'임을 기반하기 때문에 명령 집합과 구조 자체가 단순하다. 
따라서 ARM 기반 프로세서가 더 작고, 효율적이며 상대적으로 느린 것이다.

단순한 명령 집합은, 적은 수의 트랜지스터만 필요하므로 간결한 설계와 더 작은 크기를 가능케 한다. 
반도체 기본 부품인 트랜지스터는 전원을 소비해 다이의 크기를 증가시키기 때문에 스마트폰이나 태블릿PC를 위한 프로세서에는 가능한 적은 트랜지스터를 가진 것이 이상적이다.

따라서, 명령 집합의 수가 적기 때문에 트랜지스터 수가 적고 이를 통해 크기가 작고 전원 소모가 낮은 
ARM CPU가 스마트폰, 태블릿PC와 같은 모바일 기기에 많이 사용되고 있다.

### ARM 장점

소비자에 있어 ARM은 '생태계'의 하나라고 생각할 수 있다. ARM을 위해 개발된 프로세서는 오직 ARM 프로세서가 탑재된 기기에서만 실행할 수 있다. 
(즉, x86 CPU 프로세서 기반 프로그램에서는 ARM 기반 기기에서 실행할 수 없음)

따라서 ARM에서 실행되던 프로그램을 x86 프로세서에서 실행되도록 하려면 (혹은 그 반대로) 프로그램에 수정이 가해져야만 한다.

하지만, 하나의 ARM 기기에 동작하는 OS는 다른 ARM 기반 기기에서도 잘 동작한다. 이러한 장점 덕분에 수많은 버전의 안드로이드가 탄생하고 있으며 
또한 HP나 블랙베리의 태블릿에도 안드로이드가 탑재될 수 있는 가능성이 생기게 된 것이다.

(하지만 애플사는 iOS 소스코드를 공개하지 않고 있기 때문에 애플 기기는 불가능하다)

ARM을 만드는 기업들은 통해 전력 소모를 줄이고 성능을 높이기 위해 설계를 개선하며 노력하고 있다.


